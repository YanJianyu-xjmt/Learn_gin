# 令牌桶

## 1 x/time/rate

官方包                                                                                                                                                                                

### 2 API

```
type Limiter struct {
    mu     sync.Mutex
    limit  Limit
    burst  int
    tokens float64
    // last is the last time the limiter's tokens field was updated
    last time.Time
    // lastEvent is the latest time of a rate-limited event (past or future)
    lastEvent time.Time
}
```

这个结构体

这里mu 为 limit 是速度限制 

### 2.1 allow

```
// Allow is shorthand for AllowN(time.Now(), 1).
func (lim *Limiter) Allow() bool {
    return lim.AllowN(time.Now(), 1)
}
```

核心api

```
func (lim *Limiter) advance(now time.Time) (newNow time.Time, newLast time.Time, newTokens float64) {
    last := lim.last
    if now.Before(last) {
        last = now
    }

    // Calculate the new number of tokens, due to time that passed.
    elapsed := now.Sub(last)
    delta := lim.limit.tokensFromDuration(elapsed)
    tokens := lim.tokens + delta
    if burst := float64(lim.burst); tokens > burst {
        tokens = burst
    }
    return now, last, tokens
}
```

这个感觉是tokens 这里 l就是lim.last 最后的一个实践

## 3 函数介绍

```
limiter := NewLimiter(10, 1);
```

步骤

- 构建LIMIT 结构体
  
  r表示每秒可以向token 桶中产生多少token  可以是小数
  
  b 代表token的上线，最多多少容量

- 还可以哦那个every 指定 往token 桶中防止token 的间隔

   ```

```

```

```go
limit := Every(100 * time.Millisecond);
limiter := NewLimiter(limit, 1);
```

就是100ms 往桶中放一个token 本质就是一秒钟10个

wait/waitN wait方法将会 等待一会

如果不足那么wait 会阻塞一段实践  这里wait 方法有一个context 参数，可以设置context 的deadline或者timeout  来决定这次wait 最长时间



## 4 allow/allowN

就是立马看看有没有足够的token    

### 5 返回token

返回reserve函数，可以通过 reservation.Delay() 函数   或者调用cancel 函数时候，消费的token数也会归还token 桶





~~~~






